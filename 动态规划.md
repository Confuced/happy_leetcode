#数据结构与算法之美
# 40:动态规划凑单问题:
- 介绍  
双 11 满减开始, 凑够 200 优惠, 那么那些商品能凑够 200 又价钱最少.
- 0,1 背包问题  
有一组物品, 重量确定, 有一个背包, 承重确定, 如果把这组物品里面选择一些放进去背包, 最大能装多少?  
	- 第一种解法: 递归. 每次决定一个东西装或者不装. 直到结束.  
	递归树的解法是, 每次递归都有一个当前状态, 这个状态有两个属性, 一个是判断第几个节点, 一个是当前已装重量.  
	可以采用备忘录模式, 遇到相同的结点, 直接跳过.  
	而这个备忘录的形式, 是采用数组.  
	代码实现: TODO

	- 第二种解法就是动态规划, 动态规划是在备忘录思想上的进一步发展, 采用更加激进的思路, 把所有的状态都保存到数组里面去.  
	采用数组的状态结点之间的运算, 看能不能通过上一层节点状态推算出下一层的某个节点状态.  
	数组之间会有大量的空白的元素表示不可能达到的结点. 但是必须空着.  
	二维元素之间的运算只能通过数组表示.  
	代码实现: TODO
	时间复杂度是 O(n*w)  
	为什么不是 O(n), 而是 n(n*w), 是因为每一层要复制 w 个元素到下一层, 所以必须是 n*w.  
	而我们回顾递归树的时间复杂度, 是O(2^^n)  

	- 降低动态规划的空间复杂度: TODO
- 0, 1问题的升级: 这组物品再加上一个属性, 价值, 这次我们不再考量重量最大, 而是追求价值最大.  
代码实现: TDOO

- 如何迭代的算出在最终状态后,前面的选择呢? 这也是可以的. 代码实现: TODO
